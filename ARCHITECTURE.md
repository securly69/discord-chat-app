# Discord Clone - Real-Time Chat Application Architecture

## System Overview

This is a production-grade, multi-modal communication platform built with modern web technologies, integrating Stream Chat SDK, Supabase, and Clerk for a seamless, scalable Discord-like experience.

## Technology Stack

### Frontend
- **Framework**: Next.js 16 (App Router)
- **UI Library**: React 19 with Tailwind CSS v4
- **State Management**: React hooks + SWR for real-time sync
- **Authentication Client**: Clerk (JWT-based secure sessions)
- **Real-time Chat**: Stream Chat SDK

### Backend
- **Database**: Supabase (PostgreSQL)
- **Authentication**: Clerk + Supabase Auth integration
- **Real-time Messaging**: Stream Chat API
- **API**: Next.js Route Handlers (TypeScript)
- **Session Management**: Clerk JWT tokens + HTTP-only cookies

### Infrastructure
- **Deployment**: Vercel
- **Database**: Supabase PostgreSQL
- **Auth Provider**: Clerk
- **Chat Provider**: Stream
- **File Storage**: Vercel Blob (configurable)

---

## Architecture Layers

### 1. Authentication Layer (Clerk Integration)

**Flow**:
```
User → Clerk SignIn/SignUp → JWT Token → Clerk Middleware → Authenticated Routes
```

**Components**:
- `/app/(auth)/sign-in/page.tsx` - Sign-in UI
- `/app/(auth)/sign-up/page.tsx` - Sign-up UI
- `/middleware.ts` - Route protection (auto-generated by Clerk)
- `/app/api/users/sync/route.ts` - Webhook for Clerk events

**Security**:
- JWT tokens stored in HTTP-only cookies
- Server-side verification via `auth()` function
- Webhook validation using Svix signatures
- CORS protection on API routes

**User Sync Flow**:
1. User creates account in Clerk
2. Clerk sends webhook to `/api/users/sync`
3. User data synced to Supabase `users` table
4. Clerk ID stored as foreign key reference

---

### 2. Database Layer (Supabase PostgreSQL)

**Tables**:

```sql
users
├── id (PK, text - Clerk ID)
├── clerk_id (unique)
├── username
├── email
├── avatar_url
├── status (online/offline/idle/do_not_disturb)
└── timestamps

servers
├── id (PK, UUID)
├── name
├── description
├── icon_url
├── owner_id (FK → users)
└── timestamps

server_members
├── id (PK)
├── server_id (FK → servers)
├── user_id (FK → users)
├── role (owner/moderator/member)
└── joined_at

channels
├── id (PK, UUID)
├── server_id (FK → servers)
├── name
├── description
├── type (text/voice/video)
├── is_private
├── created_by (FK → users)
└── timestamps

messages
├── id (PK, UUID)
├── channel_id (FK → channels)
├── user_id (FK → users)
├── content
├── edited_at
├── deleted_at
└── created_at (indexed for ordering)

direct_messages
├── id (PK, UUID)
├── sender_id (FK → users)
├── recipient_id (FK → users)
├── content
├── read_at
└── created_at

message_attachments
├── id (PK)
├── message_id (FK → messages)
├── url
├── file_name, file_type, file_size
└── created_at

reactions
├── id (PK)
├── message_id (FK → messages)
├── user_id (FK → users)
├── emoji
└── created_at (unique constraint on message+user+emoji)

voice_sessions
├── id (PK)
├── channel_id (FK → channels)
├── user_id (FK → users)
├── session_token
├── started_at
└── ended_at

video_sessions
├── id (PK)
├── channel_id (FK → channels)
├── initiator_id (FK → users)
├── session_token
├── started_at
└── ended_at

video_participants
├── id (PK)
├── video_session_id (FK → video_sessions)
├── user_id (FK → users)
├── joined_at
└── left_at

user_presence
├── id (PK)
├── user_id (FK → users, unique)
├── channel_id (FK → channels)
└── last_seen

notifications
├── id (PK)
├── user_id (FK → users)
├── type (message/mention/call_invite/user_online)
├── related_user_id (FK → users)
├── related_message_id (FK → messages)
├── content
├── read_at
└── created_at
```

**Indexes**:
- Message lookups: `messages(channel_id)`, `messages(created_at DESC)`
- User lookups: `users(clerk_id)`, `server_members(server_id, user_id)`
- Presence updates: `user_presence(user_id)`
- Direct messages: `direct_messages(sender_id, recipient_id)`

**Row Level Security (RLS)**:
- Users can only view messages in servers they're members of
- Direct messages limited to sender/recipient
- Server data restricted to members
- Notifications visible only to recipient

---

### 3. Real-Time Chat Layer (Stream Integration)

**Stream SDK Integration**:

**Token Generation** (`/app/api/stream/token/route.ts`):
```typescript
1. Clerk user authenticated
2. Verify user ID matches request
3. Generate Stream token using STREAM_SECRET
4. Return token to client
```

**Channel Creation**:
```typescript
1. Create server/channel in Supabase
2. Initialize Stream channel with messaging type
3. Add members from Supabase server_members
4. Store Stream channel ID for reference
```

**Message Flow**:
```
Client → Message Input → API Route → Supabase INSERT 
→ Supabase Realtime Subscription → All Connected Clients
```

**Presence Tracking**:
- Stream monitors connection status
- Updates `user_presence` table on connect/disconnect
- Broadcasts user status via Supabase realtime
- Status: online/offline/idle/do_not_disturb

---

### 4. API Layer (Route Handlers)

**Authentication Routes**:
- `POST /api/users/sync` - Clerk webhook for user sync
- `POST /api/stream/token` - Generate Stream JWT token

**Chat Routes**:
- `GET /api/chat/messages?channelId=...` - Fetch paginated messages
- `POST /api/chat/messages` - Send new message
- `DELETE /api/chat/messages/[id]` - Soft delete message
- `PATCH /api/chat/messages/[id]` - Edit message

**Server Routes**:
- `GET /api/servers` - List user's servers with channels
- `POST /api/servers` - Create new server
- `PATCH /api/servers/[id]` - Update server
- `DELETE /api/servers/[id]` - Delete server

**Voice/Video Routes** (Extensible):
- `POST /api/voice/sessions` - Start voice session
- `DELETE /api/voice/sessions/[id]` - End voice session
- `POST /api/video/calls` - Initiate video call
- `POST /api/video/calls/[id]/participants` - Add participant

**Security**:
- Server-side Clerk verification on all routes
- Parameterized queries to prevent SQL injection
- Proper CORS headers
- Rate limiting ready (configure at Vercel)
- Input validation on all POST/PATCH routes

---

### 5. Frontend Layer (React Components)

**Page Structure** (`app/(main)/`):
```
(main)
├── channels/
│   ├── @me/ → Home/DM view
│   └── [id]/ → Text channel
├── voice/
│   └── [id]/ → Voice channel
├── video/
│   └── [id]/ → Video channel
└── layout.tsx → Main app container

(auth)
├── sign-in/ → Clerk sign-in
└── sign-up/ → Clerk sign-up
```

**Component Tree**:
```
RootLayout (Clerk Provider)
├── (auth)
│   └── AuthLayout
│       ├── SignInPage
│       └── SignUpPage
└── (main)
    └── MainLayout
        ├── ServerNav (fixed left sidebar)
        ├── Sidebar (channels & DMs)
        └── [Page Content]
            ├── MessageList
            │   └── MessageItem (with reactions)
            └── MessageInput
```

**State Management**:
- Component state: `useState` for local UI
- Server state: Supabase Realtime subscriptions
- Auth state: `useAuth()` hook from Clerk
- Real-time sync: Supabase channels

**Real-time Features**:
- Message streaming via Supabase `.on('postgres_changes')`
- User presence via Stream + Supabase
- Typing indicators (extensible)
- Notification badges

---

## Data Flow Diagrams

### Message Sending Flow

```
Client TextArea Input
    ↓
handleSendMessage()
    ↓
POST /api/chat/messages
    ↓
[Server Verification]
├─ Clerk auth validation
└─ Channel membership check
    ↓
Supabase INSERT messages
    ↓
Supabase Realtime Broadcast
    ↓
All Connected Clients Receive
    ↓
setMessages() state update
    ↓
UI Re-render (MessageList + MessageItem)
```

### User Authentication Flow

```
Sign-Up Form
    ↓
clerk.auth.signUp()
    ↓
Clerk Webhook → /api/users/sync
    ↓
Supabase INSERT users
    ↓
User appears in server_members
    ↓
Stream Token Generation
    ↓
Stream Channel Access
    ↓
Real-time messaging enabled
```

### Voice/Video Session Flow

```
Join Voice Button Click
    ↓
POST /api/voice/sessions
    ↓
[Verification]
├─ Clerk auth
├─ Channel access
└─ Session validity
    ↓
Supabase INSERT voice_sessions
    ↓
WebRTC Setup (via Stream)
    ↓
Audio Stream Established
    ↓
Presence Updated
    ↓
Other Users Notified
```

---

## Scalability Considerations

### Database Optimization
- **Message Pagination**: Load 50 messages at a time
- **Index Strategy**: Separate indexes for different query patterns
- **Connection Pooling**: Supabase handles via PgBouncer
- **Archive Tables**: Move old messages to archive after 90 days

### Real-time Performance
- **Broadcast Optimization**: Only send updates to subscribed clients
- **Debouncing**: Presence updates throttled to 5-second intervals
- **Channel Subscriptions**: One subscription per channel user is viewing
- **Cleanup**: Automatic unsubscribe on component unmount

### Frontend Optimization
- **Code Splitting**: Routes split automatically by Next.js
- **Image Optimization**: Use Next.js Image component
- **State Batching**: React automatic batching in event handlers
- **Lazy Loading**: Channels and servers loaded on demand

### API Rate Limiting
- Vercel: 50 requests per second per IP
- Implement token bucket for user-based limits
- Message rate limit: 5 messages per second per user

### Stream SDK Optimization
- Token refresh before expiry (45-min tokens)
- Connection pooling for multiple channels
- Lazy load Stream SDK on first use
- Cache channel permissions locally

---

## Security Implementation

### Authentication & Authorization
1. **Clerk Handles**:
   - Password hashing (bcrypt)
   - Session management
   - MFA (optional)
   - SSO integrations

2. **App Handles**:
   - Access control via `auth()` server function
   - Message permission verification
   - Channel membership enforcement
   - Rate limiting

### Data Protection
- **In Transit**: TLS 1.3 (HTTPS)
- **At Rest**: Supabase encryption
- **Tokens**: JWT with 1-hour expiry
- **Sensitive Data**: Sanitized server-side

### Input Validation
```typescript
// All API routes validate:
- channelId: UUID format
- userId: Matches authenticated user
- Content: Non-empty, <2000 chars
- Emoji: Valid Unicode
- File uploads: Size + type checks
```

### Common Attack Prevention
- **XSS**: React escapes content, CSP headers
- **CSRF**: SameSite cookies, Next.js built-in
- **SQL Injection**: Parameterized queries only
- **Privilege Escalation**: Role-based access control

---

## Environment Variables

**Required for Development**:
```
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
NEXT_PUBLIC_STREAM_KEY=your_stream_key
STREAM_SECRET=your_stream_secret
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGc...
SUPABASE_SERVICE_ROLE_KEY=eyJhbGc...
CLERK_WEBHOOK_SECRET=whsec_...
```

---

## Deployment Checklist

- [ ] Environment variables configured in Vercel
- [ ] Supabase database tables created
- [ ] RLS policies enabled and tested
- [ ] Clerk project configured
- [ ] Stream app created and keys set
- [ ] CORS headers configured
- [ ] Webhook endpoints verified
- [ ] Rate limiting configured
- [ ] Error logging enabled (Sentry optional)
- [ ] Database backups enabled
- [ ] SSL certificate valid
- [ ] Performance monitoring enabled

---

## Future Enhancements

1. **Advanced Features**:
   - Thread conversations
   - Message search/filtering
   - Custom emojis
   - Markdown formatting
   - Code block syntax highlighting

2. **Performance**:
   - Message virtualization for large channels
   - Image/video CDN caching
   - WebSocket compression
   - Message deduplication

3. **Moderation**:
   - Message moderation dashboard
   - User bans/mutes
   - Automated content filtering
   - Audit logs

4. **Analytics**:
   - Channel activity metrics
   - User engagement tracking
   - Performance monitoring
   - Error tracking (Sentry)

---

## Troubleshooting

**Common Issues**:

1. **Messages not appearing**:
   - Check Supabase subscription active
   - Verify user in server_members
   - Check browser console for errors

2. **Stream token invalid**:
   - Tokens expire after 45 min
   - Generate new token before reuse
   - Clear browser cache

3. **Slow message loading**:
   - Check database indexes exist
   - Reduce pagination limit if needed
   - Monitor query performance

4. **Real-time not working**:
   - Verify Supabase Realtime enabled
   - Check network tab for WebSocket
   - Restart development server
